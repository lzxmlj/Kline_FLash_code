; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\diskio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\diskio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\STM_Lib\inc -I.\USER -I.\CMSIS -I.\BoardHardware -I.\FATFS\src -I.\FATFS\exfuns -I.\MALLOC -I.\RTE\_407 -Ie:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Ie:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\diskio.crf FATFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;37     //初始化磁盘
;;;38     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;39     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;40     )
;;;41     {
000002  4604              MOV      r4,r0
;;;42     	u8 res=0;	    
000004  2500              MOVS     r5,#0
;;;43     	switch(pdrv)
000006  b91c              CBNZ     r4,|L1.16|
;;;44     	{
;;;45     		case SD_CARD://SD卡
;;;46     			res=SD_Init();//SD卡初始化 
000008  f7fffffe          BL       SD_Init
00000c  4605              MOV      r5,r0
;;;47       			break;
00000e  e001              B        |L1.20|
                  |L1.16|
;;;48              #if 0
;;;49     		case EX_FLASH://外部flash
;;;50     			W25QXX_Init();
;;;51     			FLASH_SECTOR_COUNT=2048*12;//W25Q1218,前12M字节给FATFS占用 
;;;52              #endif
;;;53      			break;
;;;54     		default:
;;;55     			res=1; 
000010  2501              MOVS     r5,#1
000012  bf00              NOP                            ;43
                  |L1.20|
000014  bf00              NOP                            ;47
;;;56     	}		 
;;;57     	if(res)return  STA_NOINIT;
000016  b10d              CBZ      r5,|L1.28|
000018  2001              MOVS     r0,#1
                  |L1.26|
;;;58     	else return 0; //初始化成功
;;;59     }  
00001a  bd70              POP      {r4-r6,pc}
                  |L1.28|
00001c  2000              MOVS     r0,#0                 ;58
00001e  e7fc              B        |L1.26|
;;;60     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;164    #if _USE_IOCTL
;;;165    DRESULT disk_ioctl (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;166    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;167    	BYTE cmd,		/* Control code */
;;;168    	void *buff		/* Buffer to send/receive control data */
;;;169    )
;;;170    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;171    	DRESULT res;						  			     
;;;172    	if(pdrv==SD_CARD)//SD卡
00000a  bb46              CBNZ     r6,|L2.94|
;;;173    	{
;;;174    	    switch(cmd)
00000c  f1b90f00          CMP      r9,#0
000010  d009              BEQ      |L2.38|
000012  f1b90f01          CMP      r9,#1
000016  d013              BEQ      |L2.64|
000018  f1b90f02          CMP      r9,#2
00001c  d005              BEQ      |L2.42|
00001e  f1b90f03          CMP      r9,#3
000022  d119              BNE      |L2.88|
000024  e006              B        |L2.52|
                  |L2.38|
;;;175    	    {
;;;176    		    case CTRL_SYNC:
;;;177    				res = RES_OK; 
000026  2400              MOVS     r4,#0
;;;178    		        break;	 
000028  e018              B        |L2.92|
                  |L2.42|
;;;179    		    case GET_SECTOR_SIZE:
;;;180    				*(DWORD*)buff = 512; 
00002a  f44f7000          MOV      r0,#0x200
00002e  6028              STR      r0,[r5,#0]
;;;181    		        res = RES_OK;
000030  2400              MOVS     r4,#0
;;;182    		        break;	 
000032  e013              B        |L2.92|
                  |L2.52|
;;;183    		    case GET_BLOCK_SIZE:
;;;184    				*(WORD*)buff = SDCardInfo.CardBlockSize;
000034  480c              LDR      r0,|L2.104|
000036  f8b00050          LDRH     r0,[r0,#0x50]  ; SDCardInfo
00003a  8028              STRH     r0,[r5,#0]
;;;185    		        res = RES_OK;
00003c  2400              MOVS     r4,#0
;;;186    		        break;	 
00003e  e00d              B        |L2.92|
                  |L2.64|
;;;187    		    case GET_SECTOR_COUNT:
;;;188    		        *(DWORD*)buff = SDCardInfo.CardCapacity/512;
000040  4809              LDR      r0,|L2.104|
000042  f44f7200          MOV      r2,#0x200
000046  2300              MOVS     r3,#0
000048  e9d07112          LDRD     r7,r1,[r0,#0x48]
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       __aeabi_ldivmod
000052  6028              STR      r0,[r5,#0]
;;;189    		        res = RES_OK;
000054  2400              MOVS     r4,#0
;;;190    		        break;
000056  e001              B        |L2.92|
                  |L2.88|
;;;191    		    default:
;;;192    		        res = RES_PARERR;
000058  2404              MOVS     r4,#4
;;;193    		        break;
00005a  bf00              NOP      
                  |L2.92|
00005c  e000              B        |L2.96|
                  |L2.94|
;;;194    	    }
;;;195    	}
;;;196       #if 0
;;;197         else if(pdrv==EX_FLASH)	//外部FLASH  
;;;198    	{
;;;199    	    switch(cmd)
;;;200    	    {
;;;201    		    case CTRL_SYNC:
;;;202    				res = RES_OK; 
;;;203    		        break;	 
;;;204    		    case GET_SECTOR_SIZE:
;;;205    		        *(WORD*)buff = FLASH_SECTOR_SIZE;
;;;206    		        res = RES_OK;
;;;207    		        break;	 
;;;208    		    case GET_BLOCK_SIZE:
;;;209    		        *(WORD*)buff = FLASH_BLOCK_SIZE;
;;;210    		        res = RES_OK;
;;;211    		        break;	 
;;;212    		    case GET_SECTOR_COUNT:
;;;213    		        *(DWORD*)buff = FLASH_SECTOR_COUNT;
;;;214    		        res = RES_OK;
;;;215    		        break;
;;;216    		    default:
;;;217    		        res = RES_PARERR;
;;;218    		        break;
;;;219    	    }
;;;220    	}
;;;221          #endif
;;;222         else res=RES_ERROR;//其他的不支持
00005e  2401              MOVS     r4,#1
                  |L2.96|
;;;223        return res;
000060  4620              MOV      r0,r4
;;;224    }
000062  e8bd87f0          POP      {r4-r10,pc}
;;;225    #endif
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      SDCardInfo

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;73     //count:需要读取的扇区数
;;;74     DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;75     	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;76     	BYTE *buff,		/* Data buffer to store read data */
;;;77     	DWORD sector,	/* Sector address (LBA) */
;;;78     	UINT count		/* Number of sectors to read (1..128) */
;;;79     )
;;;80     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;81     	u8 res=0; 
00000c  f04f0800          MOV      r8,#0
;;;82         if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000010  b914              CBNZ     r4,|L3.24|
000012  2004              MOVS     r0,#4
                  |L3.20|
;;;83     	switch(pdrv)
;;;84     	{
;;;85     		case SD_CARD://SD卡
;;;86     			res=SD_ReadDisk(buff,sector,count);	 
;;;87     			while(res)//读出错
;;;88     			{
;;;89     				SD_Init();	//重新初始化SD卡
;;;90     				res=SD_ReadDisk(buff,sector,count);	
;;;91     				//printf("sd rd error:%d\r\n",res);
;;;92     			}
;;;93     			break;
;;;94              #if 0
;;;95     		case EX_FLASH://外部flash
;;;96     			for(;count>0;count--)
;;;97     			{
;;;98     				W25QXX_Read(buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;99     				sector++;
;;;100    				buff+=FLASH_SECTOR_SIZE;
;;;101    			}
;;;102    			res=0;
;;;103             #endif
;;;104    			break;
;;;105    		default:
;;;106    			res=1; 
;;;107    	}
;;;108       //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;109        if(res==0x00)return RES_OK;	 
;;;110        else return RES_ERROR;	   
;;;111    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L3.24|
000018  b995              CBNZ     r5,|L3.64|
00001a  b2e2              UXTB     r2,r4                 ;86
00001c  4639              MOV      r1,r7                 ;86
00001e  4630              MOV      r0,r6                 ;86
000020  f7fffffe          BL       SD_ReadDisk
000024  4680              MOV      r8,r0                 ;86
000026  e007              B        |L3.56|
                  |L3.40|
000028  f7fffffe          BL       SD_Init
00002c  b2e2              UXTB     r2,r4                 ;90
00002e  4639              MOV      r1,r7                 ;90
000030  4630              MOV      r0,r6                 ;90
000032  f7fffffe          BL       SD_ReadDisk
000036  4680              MOV      r8,r0                 ;90
                  |L3.56|
000038  f1b80f00          CMP      r8,#0                 ;87
00003c  d1f4              BNE      |L3.40|
00003e  e002              B        |L3.70|
                  |L3.64|
000040  f04f0801          MOV      r8,#1                 ;106
000044  bf00              NOP                            ;83
                  |L3.70|
000046  bf00              NOP                            ;93
000048  f1b80f00          CMP      r8,#0                 ;109
00004c  d101              BNE      |L3.82|
00004e  2000              MOVS     r0,#0                 ;109
000050  e7e0              B        |L3.20|
                  |L3.82|
000052  2001              MOVS     r0,#1                 ;110
000054  e7de              B        |L3.20|
;;;112    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;61     //获得磁盘状态
;;;62     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;63     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;64     )
;;;65     { 
;;;66     	return 0;
000002  2000              MOVS     r0,#0
;;;67     } 
000004  4770              BX       lr
;;;68     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;118    #if _USE_WRITE
;;;119    DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;120    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;121    	const BYTE *buff,	/* Data to be written */
;;;122    	DWORD sector,		/* Sector address (LBA) */
;;;123    	UINT count			/* Number of sectors to write (1..128) */
;;;124    )
;;;125    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;126    	u8 res=0;  
00000c  f04f0800          MOV      r8,#0
;;;127        if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000010  b914              CBNZ     r4,|L5.24|
000012  2004              MOVS     r0,#4
                  |L5.20|
;;;128    	switch(pdrv)
;;;129    	{
;;;130    		case SD_CARD://SD卡
;;;131    			res=SD_WriteDisk((u8*)buff,sector,count);
;;;132    			while(res)//写出错
;;;133    			{
;;;134    				SD_Init();	//重新初始化SD卡
;;;135    				res=SD_WriteDisk((u8*)buff,sector,count);	
;;;136    				//printf("sd wr error:%d\r\n",res);
;;;137    			}
;;;138    			break;
;;;139             #if 0
;;;140    		case EX_FLASH://外部flash
;;;141    			for(;count>0;count--)
;;;142    			{										    
;;;143    				W25QXX_Write((u8*)buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;144    				sector++;
;;;145    				buff+=FLASH_SECTOR_SIZE;
;;;146    			}
;;;147    			res=0;
;;;148             #endif
;;;149    			break;
;;;150    		default:
;;;151    			res=1; 
;;;152    	}
;;;153        //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;154        if(res == 0x00)return RES_OK;	 
;;;155        else return RES_ERROR;	
;;;156    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L5.24|
000018  b995              CBNZ     r5,|L5.64|
00001a  b2e2              UXTB     r2,r4                 ;131
00001c  4639              MOV      r1,r7                 ;131
00001e  4630              MOV      r0,r6                 ;131
000020  f7fffffe          BL       SD_WriteDisk
000024  4680              MOV      r8,r0                 ;131
000026  e007              B        |L5.56|
                  |L5.40|
000028  f7fffffe          BL       SD_Init
00002c  b2e2              UXTB     r2,r4                 ;135
00002e  4639              MOV      r1,r7                 ;135
000030  4630              MOV      r0,r6                 ;135
000032  f7fffffe          BL       SD_WriteDisk
000036  4680              MOV      r8,r0                 ;135
                  |L5.56|
000038  f1b80f00          CMP      r8,#0                 ;132
00003c  d1f4              BNE      |L5.40|
00003e  e002              B        |L5.70|
                  |L5.64|
000040  f04f0801          MOV      r8,#1                 ;151
000044  bf00              NOP                            ;128
                  |L5.70|
000046  bf00              NOP                            ;138
000048  f1b80f00          CMP      r8,#0                 ;154
00004c  d101              BNE      |L5.82|
00004e  2000              MOVS     r0,#0                 ;154
000050  e7e0              B        |L5.20|
                  |L5.82|
000052  2001              MOVS     r0,#1                 ;155
000054  e7de              B        |L5.20|
;;;157    #endif
                          ENDP


                          AREA ||i.ff_memalloc||, CODE, READONLY, ALIGN=1

                  ff_memalloc PROC
;;;234    //动态分配内存
;;;235    void *ff_memalloc (UINT size)			
000000  b510              PUSH     {r4,lr}
;;;236    {
000002  4604              MOV      r4,r0
;;;237    	return (void*)mymalloc(SRAMIN,size);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       mymalloc
;;;238    }
00000c  bd10              POP      {r4,pc}
;;;239    //释放内存
                          ENDP


                          AREA ||i.ff_memfree||, CODE, READONLY, ALIGN=1

                  ff_memfree PROC
;;;239    //释放内存
;;;240    void ff_memfree (void* mf)		 
000000  b510              PUSH     {r4,lr}
;;;241    {
000002  4604              MOV      r4,r0
;;;242    	myfree(SRAMIN,mf);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       myfree
;;;243    }
00000c  bd10              POP      {r4,pc}
;;;244    
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;229    //15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */                                                                                                                                                                                                                                                
;;;230    DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;231    {				 
;;;232    	return 0;
;;;233    }			 
000002  4770              BX       lr
;;;234    //动态分配内存
                          ENDP


;*** Start embedded assembler ***

#line 1 "FATFS\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REV16|
#line 388 ".\\CMSIS\\cmsis_armcc.h"
|__asm___8_diskio_c_b3252454____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REVSH|
#line 402
|__asm___8_diskio_c_b3252454____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____RRX|
#line 587
|__asm___8_diskio_c_b3252454____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
