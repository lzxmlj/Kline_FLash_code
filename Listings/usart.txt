; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\STM_Lib\inc -I.\USER -I.\CMSIS -I.\BoardHardware -I.\FATFS\src -I.\FATFS\exfuns -I.\MALLOC -I.\RTE\_407 -Ie:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Ie:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\usart.crf USER\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;62       
;;;63     void USART1_IRQHandler(void)
000000  491c              LDR      r1,|L1.116|
;;;64     {
;;;65     	u8 res;	
;;;66     #if SYSTEM_SUPPORT_OS 		//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
;;;67     	OSIntEnter();    
;;;68     #endif
;;;69     	if(USART1->SR&(1<<5))//接收到数据
000002  8809              LDRH     r1,[r1,#0]
000004  f0010120          AND      r1,r1,#0x20
000008  b309              CBZ      r1,|L1.78|
;;;70     	{	 
;;;71     		res=USART1->DR; 
00000a  491a              LDR      r1,|L1.116|
00000c  8889              LDRH     r1,[r1,#4]
00000e  b2c8              UXTB     r0,r1
;;;72     		if((USART_RX_STA&0x8000)==0)//接收未完成
000010  4919              LDR      r1,|L1.120|
000012  8809              LDRH     r1,[r1,#0]  ; USART_RX_STA
000014  f4014100          AND      r1,r1,#0x8000
000018  b9c9              CBNZ     r1,|L1.78|
;;;73     		{
;;;74     			if(USART_RX_STA&0x4000)//接收到了0x0d
00001a  4917              LDR      r1,|L1.120|
00001c  8809              LDRH     r1,[r1,#0]  ; USART_RX_STA
00001e  f4014180          AND      r1,r1,#0x4000
000022  b161              CBZ      r1,|L1.62|
;;;75     			{
;;;76     				if(res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
000024  280a              CMP      r0,#0xa
000026  d003              BEQ      |L1.48|
000028  2100              MOVS     r1,#0
00002a  4a13              LDR      r2,|L1.120|
00002c  8011              STRH     r1,[r2,#0]
00002e  e020              B        |L1.114|
                  |L1.48|
;;;77     				else USART_RX_STA|=0x8000;	//接收完成了 
000030  4911              LDR      r1,|L1.120|
000032  8809              LDRH     r1,[r1,#0]  ; USART_RX_STA
000034  f4414100          ORR      r1,r1,#0x8000
000038  4a0f              LDR      r2,|L1.120|
00003a  8011              STRH     r1,[r2,#0]
00003c  e019              B        |L1.114|
                  |L1.62|
;;;78     			}else //还没收到0X0D
;;;79     			{	
;;;80     				if(res==0x0d)USART_RX_STA|=0x4000;
00003e  280d              CMP      r0,#0xd
000040  d106              BNE      |L1.80|
000042  490d              LDR      r1,|L1.120|
000044  8809              LDRH     r1,[r1,#0]  ; USART_RX_STA
000046  f4414180          ORR      r1,r1,#0x4000
00004a  4a0b              LDR      r2,|L1.120|
00004c  8011              STRH     r1,[r2,#0]
                  |L1.78|
00004e  e010              B        |L1.114|
                  |L1.80|
;;;81     				else
;;;82     				{
;;;83     					USART_RX_BUF[USART_RX_STA&0X3FFF]=res;
000050  4909              LDR      r1,|L1.120|
000052  8809              LDRH     r1,[r1,#0]  ; USART_RX_STA
000054  f3c1010d          UBFX     r1,r1,#0,#14
000058  4a08              LDR      r2,|L1.124|
00005a  5450              STRB     r0,[r2,r1]
;;;84     					USART_RX_STA++;
00005c  4906              LDR      r1,|L1.120|
00005e  8809              LDRH     r1,[r1,#0]  ; USART_RX_STA
000060  1c49              ADDS     r1,r1,#1
000062  4a05              LDR      r2,|L1.120|
000064  8011              STRH     r1,[r2,#0]
;;;85     					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
000066  4611              MOV      r1,r2
000068  8809              LDRH     r1,[r1,#0]  ; USART_RX_STA
00006a  29c7              CMP      r1,#0xc7
00006c  dd01              BLE      |L1.114|
00006e  2100              MOVS     r1,#0
000070  8011              STRH     r1,[r2,#0]
                  |L1.114|
;;;86     				}		 
;;;87     			}
;;;88     		}  		 									     
;;;89     	} 
;;;90     #if SYSTEM_SUPPORT_OS 	//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
;;;91     	OSIntExit();  											 
;;;92     #endif
;;;93     } 
000072  4770              BX       lr
;;;94     #endif										 
                          ENDP

                  |L1.116|
                          DCD      0x40011000
                  |L1.120|
                          DCD      USART_RX_STA
                  |L1.124|
                          DCD      USART_RX_BUF

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;37     //定义_sys_exit()以避免使用半主机模式    
;;;38     void _sys_exit(int x) 
000000  bf00              NOP      
;;;39     { 
;;;40     	x = x; 
;;;41     } 
000002  4770              BX       lr
;;;42     //重定义fputc函数 
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;42     //重定义fputc函数 
;;;43     int fputc(int ch, FILE *f)
000000  bf00              NOP      
                  |L3.2|
;;;44     {      
;;;45     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000002  4a05              LDR      r2,|L3.24|
000004  8812              LDRH     r2,[r2,#0]
000006  f0020240          AND      r2,r2,#0x40
00000a  2a00              CMP      r2,#0
00000c  d0f9              BEQ      |L3.2|
;;;46     	USART1->DR = (u8) ch;      
00000e  b2c2              UXTB     r2,r0
000010  4b01              LDR      r3,|L3.24|
000012  809a              STRH     r2,[r3,#4]
;;;47     	return ch;
;;;48     }
000014  4770              BX       lr
;;;49     #endif 
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0x40011000

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;97     //bound:波特率 
;;;98     void uart_init(u32 pclk2,u32 bound)
000000  b5f0              PUSH     {r4-r7,lr}
;;;99     {  	 
000002  ed2d8b02          VPUSH    {d8}
000006  b083              SUB      sp,sp,#0xc
000008  4605              MOV      r5,r0
00000a  460e              MOV      r6,r1
;;;100    	float temp;
;;;101    	u16 mantissa;
;;;102    	u16 fraction;	   
;;;103    	temp=(float)(pclk2*1000000)/(bound*16);//得到USARTDIV@OVER8=0
00000c  4938              LDR      r1,|L4.240|
00000e  fb05f001          MUL      r0,r5,r1
000012  ee000a10          VMOV     s0,r0
000016  eef80a40          VCVT.F32.U32 s1,s0
00001a  0130              LSLS     r0,r6,#4
00001c  ee000a10          VMOV     s0,r0
000020  eeb80a40          VCVT.F32.U32 s0,s0
000024  ee801a80          VDIV.F32 s2,s1,s0
000028  eeb08a41          VMOV.F32 s16,s2
;;;104    	mantissa=temp;				 //得到整数部分
00002c  eebc0ac8          VCVT.U32.F32 s0,s16
000030  ee100a10          VMOV     r0,s0
000034  b284              UXTH     r4,r0
;;;105    	fraction=(temp-mantissa)*16; //得到小数部分@OVER8=0 
000036  ee004a10          VMOV     s0,r4
00003a  eeb80a40          VCVT.F32.U32 s0,s0
00003e  ee380a40          VSUB.F32 s0,s16,s0
000042  eef30a00          VMOV.F32 s1,#16.00000000
000046  ee200a20          VMUL.F32 s0,s0,s1
00004a  eebc0ac0          VCVT.U32.F32 s0,s0
00004e  ee107a10          VMOV     r7,s0
;;;106        mantissa<<=4;
000052  f64f70ff          MOV      r0,#0xffff
000056  ea001404          AND      r4,r0,r4,LSL #4
;;;107    	mantissa+=fraction; 
00005a  19e0              ADDS     r0,r4,r7
00005c  b284              UXTH     r4,r0
;;;108    	RCC->AHB1ENR|=1<<0;   	//使能PORTA口时钟  
00005e  4825              LDR      r0,|L4.244|
000060  6800              LDR      r0,[r0,#0]
000062  f0400001          ORR      r0,r0,#1
000066  4923              LDR      r1,|L4.244|
000068  6008              STR      r0,[r1,#0]
;;;109    	RCC->APB2ENR|=1<<4;  	//使能串口1时钟 
00006a  4822              LDR      r0,|L4.244|
00006c  3014              ADDS     r0,r0,#0x14
00006e  6800              LDR      r0,[r0,#0]
000070  f0400010          ORR      r0,r0,#0x10
000074  491f              LDR      r1,|L4.244|
000076  3114              ADDS     r1,r1,#0x14
000078  6008              STR      r0,[r1,#0]
;;;110    	GPIO_Set(GPIOA,PIN9|PIN10,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_50M,GPIO_PUPD_PU);//PA9,PA10,复用功能,上拉输出
00007a  2001              MOVS     r0,#1
00007c  2102              MOVS     r1,#2
00007e  2300              MOVS     r3,#0
000080  460a              MOV      r2,r1
000082  e9cd1000          STRD     r1,r0,[sp,#0]
000086  f44f61c0          MOV      r1,#0x600
00008a  481b              LDR      r0,|L4.248|
00008c  f7fffffe          BL       GPIO_Set
;;;111     	GPIO_AF_Set(GPIOA,9,7);	//PA9,AF7
000090  2207              MOVS     r2,#7
000092  2109              MOVS     r1,#9
000094  4818              LDR      r0,|L4.248|
000096  f7fffffe          BL       GPIO_AF_Set
;;;112    	GPIO_AF_Set(GPIOA,10,7);//PA10,AF7  	   
00009a  2207              MOVS     r2,#7
00009c  210a              MOVS     r1,#0xa
00009e  4816              LDR      r0,|L4.248|
0000a0  f7fffffe          BL       GPIO_AF_Set
;;;113    	//波特率设置
;;;114     	USART1->BRR=mantissa; 	//波特率设置	 
0000a4  4815              LDR      r0,|L4.252|
0000a6  8104              STRH     r4,[r0,#8]
;;;115    	USART1->CR1&=~(1<<15); 	//设置OVER8=0 
0000a8  8980              LDRH     r0,[r0,#0xc]
0000aa  f4204000          BIC      r0,r0,#0x8000
0000ae  4913              LDR      r1,|L4.252|
0000b0  8188              STRH     r0,[r1,#0xc]
;;;116    	USART1->CR1|=1<<3;  	//串口发送使能 
0000b2  4608              MOV      r0,r1
0000b4  8980              LDRH     r0,[r0,#0xc]
0000b6  f0400008          ORR      r0,r0,#8
0000ba  8188              STRH     r0,[r1,#0xc]
;;;117    #if EN_USART1_RX		  	//如果使能了接收
;;;118    	//使能接收中断 
;;;119    	USART1->CR1|=1<<2;  	//串口接收使能
0000bc  4608              MOV      r0,r1
0000be  8980              LDRH     r0,[r0,#0xc]
0000c0  f0400004          ORR      r0,r0,#4
0000c4  8188              STRH     r0,[r1,#0xc]
;;;120    	USART1->CR1|=1<<5;    	//接收缓冲区非空中断使能	    	
0000c6  4608              MOV      r0,r1
0000c8  8980              LDRH     r0,[r0,#0xc]
0000ca  f0400020          ORR      r0,r0,#0x20
0000ce  8188              STRH     r0,[r1,#0xc]
;;;121    	MY_NVIC_Init(3,3,USART1_IRQn,2);//组2，最低优先级 
0000d0  2302              MOVS     r3,#2
0000d2  2225              MOVS     r2,#0x25
0000d4  2103              MOVS     r1,#3
0000d6  4608              MOV      r0,r1
0000d8  f7fffffe          BL       MY_NVIC_Init
;;;122    #endif
;;;123    	USART1->CR1|=1<<13;  	//串口使能
0000dc  4807              LDR      r0,|L4.252|
0000de  8980              LDRH     r0,[r0,#0xc]
0000e0  f4405000          ORR      r0,r0,#0x2000
0000e4  4905              LDR      r1,|L4.252|
0000e6  8188              STRH     r0,[r1,#0xc]
;;;124    }
0000e8  b003              ADD      sp,sp,#0xc
0000ea  ecbd8b02          VPOP     {d8}
0000ee  bdf0              POP      {r4-r7,pc}
;;;125    
                          ENDP

                  |L4.240|
                          DCD      0x000f4240
                  |L4.244|
                          DCD      0x40023830
                  |L4.248|
                          DCD      0x40020000
                  |L4.252|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  USART_RX_STA
000004  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "USER\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_9275e5e5____REV16|
#line 388 ".\\CMSIS\\cmsis_armcc.h"
|__asm___7_usart_c_9275e5e5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_9275e5e5____REVSH|
#line 402
|__asm___7_usart_c_9275e5e5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_9275e5e5____RRX|
#line 587
|__asm___7_usart_c_9275e5e5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
